<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css"><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:new URL("http://note.niubishanshan.top").hostname,root:"/",scheme:"Gemini",version:"7.7.0",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1},copycode:{enable:!1,show_result:!1,style:null},back2top:{enable:!0,sidebar:!1,scrollpercent:!0},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!1,mediumzoom:!1,lazyload:!1,pangu:!1,comments:{style:"tabs",active:null,storage:!0,lazyload:!1,nav:null},algolia:{appID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},path:"search.json",motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}}}</script><meta name="description" content="浏览器缓存分为两种: 一种是需要发送 HTTP 请求, 基于服务器的判断来决定是否使用缓存, 即协商缓存. 还有一种为不需要发送 HTTP 请求, 直接读取浏览器存储在本地的缓存内容作为结果返回, 即强缓存. 强缓存强缓存, 就是浏览器直接读取本地缓存, 无需通过服务器确认的缓存形式. 在 http  1.0 时期, 定义的 Expires 字段就是控制了响应强缓存的有效时间."><meta property="og:type" content="article"><meta property="og:title" content="浏览器缓存"><meta property="og:url" content="http://note.niubishanshan.top/%E9%9D%A2%E8%AF%95/%E6%B5%8F%E8%A7%88%E5%99%A8/%E9%9D%A2%E8%AF%95/%E6%B5%8F%E8%A7%88%E5%99%A8/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/index.html"><meta property="og:site_name" content="圈圈的笔记"><meta property="og:description" content="浏览器缓存分为两种: 一种是需要发送 HTTP 请求, 基于服务器的判断来决定是否使用缓存, 即协商缓存. 还有一种为不需要发送 HTTP 请求, 直接读取浏览器存储在本地的缓存内容作为结果返回, 即强缓存. 强缓存强缓存, 就是浏览器直接读取本地缓存, 无需通过服务器确认的缓存形式. 在 http  1.0 时期, 定义的 Expires 字段就是控制了响应强缓存的有效时间."><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2021-12-14T02:36:42.000Z"><meta property="article:modified_time" content="2024-06-27T15:04:43.300Z"><meta property="article:author" content="圈圈的圈"><meta property="article:tag" content="面试"><meta name="twitter:card" content="summary"><link rel="canonical" href="http://note.niubishanshan.top/%E9%9D%A2%E8%AF%95/%E6%B5%8F%E8%A7%88%E5%99%A8/%E9%9D%A2%E8%AF%95/%E6%B5%8F%E8%A7%88%E5%99%A8/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0}</script><title>浏览器缓存 | 圈圈的笔记</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div> <a target="_blank" rel="noopener" href="https://github.com/luoquanquan" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513;color:#fff;position:absolute;top:0;border:0;right:0" aria-hidden="true"><path d="M0 0 115 115 130 115 142 142 250 250 250 0Z"></path><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4L133.7 101.6C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-meta"><div><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">圈圈的笔记</span><span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle">路漫漫其修远兮, 吾将上下而求索</p></div><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-fw fa-home"></i> 首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i> 标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i> 分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i> 归档</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i> 关于</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i> 搜索</a></li></ul></nav><div class="site-search"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"> <input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="搜索..." spellcheck="false" type="text" id="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"></div></div><div class="search-pop-overlay"></div></div></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content"><div class="posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://note.niubishanshan.top/%E9%9D%A2%E8%AF%95/%E6%B5%8F%E8%A7%88%E5%99%A8/%E9%9D%A2%E8%AF%95/%E6%B5%8F%E8%A7%88%E5%99%A8/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.png"><meta itemprop="name" content="圈圈的圈"><meta itemprop="description" content="技术学习, 读书笔记, 生活感悟 ~"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="圈圈的笔记"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> 浏览器缓存</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2021-12-14 10:36:42" itemprop="dateCreated datePublished" datetime="2021-12-14T10:36:42+08:00">2021-12-14</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i></span> <span class="post-meta-item-text">更新于</span> <time title="修改时间：2024-06-27 23:04:43" itemprop="dateModified" datetime="2024-06-27T23:04:43+08:00">2024-06-27</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">面试</span></a></span> ， <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E9%9D%A2%E8%AF%95/%E6%B5%8F%E8%A7%88%E5%99%A8/" itemprop="url" rel="index"><span itemprop="name">浏览器</span></a></span></span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i></span> <span class="post-meta-item-text">阅读次数：</span><span id="busuanzi_value_page_pv"></span></span></div></header><div class="post-body" itemprop="articleBody"><p>浏览器缓存分为两种: 一种是需要发送 HTTP 请求, 基于服务器的判断来决定是否使用缓存, 即协商缓存. 还有一种为不需要发送 HTTP 请求, 直接读取浏览器存储在本地的缓存内容作为结果返回, 即强缓存.</p><h2 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h2><p>强缓存, 就是浏览器直接读取本地缓存, 无需通过服务器确认的缓存形式. 在 http 1.0 时期, 定义的 Expires 字段就是控制了响应强缓存的有效时间.</p><span id="more"></span><h3 id="expires-Wed-26-Oct-2022-16-00-15-GMT"><a href="#expires-Wed-26-Oct-2022-16-00-15-GMT" class="headerlink" title="expires: Wed, 26 Oct 2022 16:00:15 GMT"></a>expires: Wed, 26 Oct 2022 16:00:15 GMT</h3><p>表示当前资源缓存到 2022 年 10 月 26 号 16:00:25 过期, 此前无需再次向服务器发起请求. 但是此方案存在一个问题. 就是如果服务器和浏览器时间不一致. 那么会导致后端返回的时间和前端理解的有效时间不一致. 于是在 http 1.1 中添加了 cache-control 通过 max-age&#x3D;相对时间(单位秒)避免了两端时间不一致可能出现的问题</p><h3 id="cache-control-max-age-x3D-31536000"><a href="#cache-control-max-age-x3D-31536000" class="headerlink" title="cache-control: max-age&#x3D;31536000"></a>cache-control: max-age&#x3D;31536000</h3><p>max-age 为 31536000 秒也就是 365 天有效期为一年. 由于使用的是相对时间. 缓存的实际有效期根据浏览器接收到资源的时间开始算. 避免了客户端 &#x2F; 服务端时间不同步的问题.</p><p>cache-control 还包含以下几个属性值:</p><ul><li>public: 浏览器和代理服务器都可以缓存</li><li>s-maxage: 启用了代理服务器缓存时用于规定代理服务器缓存的时间</li><li>private: 只有浏览器可以缓存, 代理服务器不可以缓存</li><li>no-cache: 跳过当前的强缓存, 发送 http 请求直接进入协商缓存阶段</li><li>no-store: 跳过任何形式的缓存</li><li>must-revalidate: 一旦资源过期(比如已经超过max-age), 在成功向原始服务器验证之前, 缓存不能用该资源响应后续请求</li></ul><p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cache-Control">查考文档</a></p><p>PS: 强缓存中如果 Expires 和 cache-control 两个响应头都存在的话, 浏览器会优先考虑 cache-control</p><h2 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h2><p>强缓存失效后, 浏览器就会向服务器发起 http 请求, 并携带相应的缓存 tag, 由服务器确定是否使用缓存的资源. 这个过程就是协商缓存. 这样的 tag 组要有两个 last-modified 和 etag</p><h3 id="last-modified"><a href="#last-modified" class="headerlink" title="last-modified"></a>last-modified</h3><p>表示文件最后修改的时间, 浏览器第一次向服务器发送请求时服务器会在响应头上携带这个字段. 浏览器再次请求相同的内容时就会带上对应的请求头: if-modified-since 用于表示上次收到的文件的更新时间. 服务器拿到该字段以后会和服务器中该资源的最后一次修改时间做对比:</p><ol><li>如果请求头中的时间小于最近修改时间, 说明是时候更新了. 返回最新资源并返回最新的 last-modified</li><li>如果请求头中的时间等于最后更新时间, 则返回 304 告诉浏览器直接使用缓存</li></ol><h3 id="etag"><a href="#etag" class="headerlink" title="etag"></a>etag</h3><p>etag 是服务器根据当前文件内容生成的一段唯一标识. 只要文件内容有改动这个标识就会更新. 当浏览器第一次访问资源时, 服务器会将该标识作为 etag 响应头返回给浏览器, 下次访问时浏览器会携带 if-none-match 请求头并以该值作为请求头的值. 服务器拿这个值和资源当前的 etag 做对比:</p><ol><li>如果两者不一样, 说明要更新了. 执行常规的请求响应逻辑</li><li>如果两者一样, 则返回 304 通知浏览器使用缓存</li></ol><h3 id="last-modified-vs-etag"><a href="#last-modified-vs-etag" class="headerlink" title="last-modified vs etag"></a>last-modified vs etag</h3><ol><li>在精准度上, etag 优于 last-modified. 因为 etag 是基于文件内容生成的每次文件的变动都能带来 etag 的更新. Last-modified 就存在了两种缺点:<ul><li>用户通过编辑器打开了文件并保存, 期间并没有修改文件内容, last-modified 也会更新</li><li>last-modified 能够感知的最精确的时间是秒, 如果 1s 内经历了多次修改. last-modified 并不能体现出文件修改的结果…</li></ul></li><li>在性能上, last-modified 优于 etag. 优于 last-modified 的更新时间就是右键属性里边的更新时间. 读取方便. 但是 etag 就要对文件内容进行摘要生成的哈希值. 肯定资源开销更大一些</li><li>两种协商缓存字段同时使用的话, 服务器会优先考虑 etag</li></ol><h2 id="缓存位置"><a href="#缓存位置" class="headerlink" title="缓存位置"></a>缓存位置</h2><p>当命中强缓存或者协商缓存的时候, 浏览器就会从本地缓存中获取资源. 那么本地的缓存是存在哪儿的呢? 浏览器的缓存位置按照优先级从高到低的排序分别是:</p><h3 id="Service-Woker"><a href="#Service-Woker" class="headerlink" title="Service Woker"></a>Service Woker</h3><p>Service Woker, 可以链接浏览器的请求. 以请求粒度控制网站中各个资源的缓存情况. 在 pwa 中比较常用.</p><h3 id="Memory-Cache-和-Disk-Cache"><a href="#Memory-Cache-和-Disk-Cache" class="headerlink" title="Memory Cache 和 Disk Cache"></a>Memory Cache 和 Disk Cache</h3><p>Memory Cache 和 Disk Cache 是目前比较常用的两种情况. 顾名思义, 一种是把缓存资源存储在内存中, 一种是存储在硬盘中. 两者的选择应该是遵循了 lru-cache 的最长使用原则.</p><h3 id="Push-Cache"><a href="#Push-Cache" class="headerlink" title="Push Cache"></a>Push Cache</h3><p>Push Cache, 源于 http 2.0 的服务器推送功能, 我目前在业务中还没有具体的实践. 如果您有好的想法的话希望可以分享一下 ~</p></div><footer class="post-footer"><div class="post-tags"> <a href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag"># 面试</a></div><div class="post-nav"><div class="post-nav-item"><a href="/%E9%9D%A2%E8%AF%95/Vue/%E9%9D%A2%E8%AF%95/Vue/Vue%20%E4%B8%AD%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E5%92%8C%20method%20%E7%9A%84%E5%8C%BA%E5%88%AB/" rel="prev" title="Vue 中计算属性和 method 的区别"><i class="fa fa-chevron-left"></i> Vue 中计算属性和 method 的区别</a></div><div class="post-nav-item"> <a href="/%E9%9D%A2%E8%AF%95/%E6%B5%8F%E8%A7%88%E5%99%A8/%E9%9D%A2%E8%AF%95/%E6%B5%8F%E8%A7%88%E5%99%A8/DOM%20%E4%BA%8B%E4%BB%B6/" rel="next" title="DOM 事件">DOM 事件<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div></div><script>
  window.addEventListener('tabs:register', function() {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc"> 文章目录</li><li class="sidebar-nav-overview"> 站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%BA%E7%BC%93%E5%AD%98"><span class="nav-text">强缓存</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#expires-Wed-26-Oct-2022-16-00-15-GMT"><span class="nav-text">expires: Wed, 26 Oct 2022 16:00:15 GMT</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#cache-control-max-age-x3D-31536000"><span class="nav-text">cache-control: max-age&#x3D;31536000</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98"><span class="nav-text">协商缓存</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#last-modified"><span class="nav-text">last-modified</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#etag"><span class="nav-text">etag</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#last-modified-vs-etag"><span class="nav-text">last-modified vs etag</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E4%BD%8D%E7%BD%AE"><span class="nav-text">缓存位置</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Service-Woker"><span class="nav-text">Service Woker</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Memory-Cache-%E5%92%8C-Disk-Cache"><span class="nav-text">Memory Cache 和 Disk Cache</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Push-Cache"><span class="nav-text">Push Cache</span></a></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" alt="圈圈的圈" src="/images/avatar.png"><p class="site-author-name" itemprop="name">圈圈的圈</p><div class="site-description" itemprop="description">技术学习, 读书笔记, 生活感悟 ~</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"> <a href="/archives/"><span class="site-state-item-count">142</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"> <a href="/categories/"><span class="site-state-item-count">35</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"> <a href="/tags/"><span class="site-state-item-count">8</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://juejin.im/user/5837c2bd61ff4b006ca8d1b2" title="掘金 → https:&#x2F;&#x2F;juejin.im&#x2F;user&#x2F;5837c2bd61ff4b006ca8d1b2" rel="noopener" target="_blank"><i class="fa fa-fw fa-stack-overflow"></i> 掘金</a></span><span class="links-of-author-item"><a href="https://github.com/luoquanquan" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;luoquanquan" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i> GitHub</a></span><span class="links-of-author-item"><a href="mailto:luo_quanquan@163.com" title="E-Mail → mailto:luo_quanquan@163.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i> E-Mail</a></span></div></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="beian"><a href="http://www.beian.miit.gov.cn/" rel="noopener" target="_blank">京ICP备17034706号-1</a></div><div class="copyright"> &copy; <span itemprop="copyrightYear">2024</span><span class="with-love"><i class="fa fa-user"></i></span> <span class="author" itemprop="copyrightHolder">圈圈的圈</span></div><div class="busuanzi-count"><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="post-meta-item" id="busuanzi_container_site_uv"><span class="post-meta-item-icon"><i class="fa fa-user"></i></span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span></span></span> <span class="post-meta-divider">|</span><span class="post-meta-item" id="busuanzi_container_site_pv"><span class="post-meta-item-icon"><i class="fa fa-eye"></i></span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div></div></footer></div><script color="0,0,255" opacity="0.5" zindex="-1" count="99" src="/js/theme-next-canvas-nest/canvas-nest.min.js"></script><script src="/lib/anime.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script><script src="/js/local-search.js"></script></body></html>