<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css"><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:new URL("http://note.niubishanshan.top").hostname,root:"/",scheme:"Gemini",version:"7.7.0",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1},copycode:{enable:!1,show_result:!1,style:null},back2top:{enable:!0,sidebar:!1,scrollpercent:!0},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!1,mediumzoom:!1,lazyload:!1,pangu:!1,comments:{style:"tabs",active:null,storage:!0,lazyload:!1,nav:null},algolia:{appID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},path:"search.json",motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}}}</script><meta name="description" content="所谓垃圾回收机制, 就是浏览器回收内存的方案. 在浏览器发展历程中充当了主流 GC 的方案主要有: 引用计数法和标记清除法 引用计数法比较初级的垃圾回收方案, 目前几乎已经被完全淘汰. 在引用计数法的机制下, 内存中每个值都会对应一个引用计数. 当垃圾回收器感受到某个值的引用计数已经为 0 时, 就判定为该变量已经是无用的变量了. 对应的内存就会被释放掉."><meta property="og:type" content="article"><meta property="og:title" content="垃圾回收机制"><meta property="og:url" content="http://note.niubishanshan.top/%E9%9D%A2%E8%AF%95/%E6%B5%8F%E8%A7%88%E5%99%A8/%E9%9D%A2%E8%AF%95/%E6%B5%8F%E8%A7%88%E5%99%A8/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/index.html"><meta property="og:site_name" content="圈圈的笔记"><meta property="og:description" content="所谓垃圾回收机制, 就是浏览器回收内存的方案. 在浏览器发展历程中充当了主流 GC 的方案主要有: 引用计数法和标记清除法 引用计数法比较初级的垃圾回收方案, 目前几乎已经被完全淘汰. 在引用计数法的机制下, 内存中每个值都会对应一个引用计数. 当垃圾回收器感受到某个值的引用计数已经为 0 时, 就判定为该变量已经是无用的变量了. 对应的内存就会被释放掉."><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2021-12-13T12:49:12.000Z"><meta property="article:modified_time" content="2024-06-27T15:04:43.299Z"><meta property="article:author" content="圈圈的圈"><meta property="article:tag" content="面试"><meta name="twitter:card" content="summary"><link rel="canonical" href="http://note.niubishanshan.top/%E9%9D%A2%E8%AF%95/%E6%B5%8F%E8%A7%88%E5%99%A8/%E9%9D%A2%E8%AF%95/%E6%B5%8F%E8%A7%88%E5%99%A8/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0}</script><title>垃圾回收机制 | 圈圈的笔记</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div> <a target="_blank" rel="noopener" href="https://github.com/luoquanquan" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513;color:#fff;position:absolute;top:0;border:0;right:0" aria-hidden="true"><path d="M0 0 115 115 130 115 142 142 250 250 250 0Z"></path><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4L133.7 101.6C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-meta"><div><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">圈圈的笔记</span><span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle">路漫漫其修远兮, 吾将上下而求索</p></div><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-fw fa-home"></i> 首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i> 标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i> 分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i> 归档</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i> 关于</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i> 搜索</a></li></ul></nav><div class="site-search"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"> <input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="搜索..." spellcheck="false" type="text" id="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"></div></div><div class="search-pop-overlay"></div></div></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content"><div class="posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://note.niubishanshan.top/%E9%9D%A2%E8%AF%95/%E6%B5%8F%E8%A7%88%E5%99%A8/%E9%9D%A2%E8%AF%95/%E6%B5%8F%E8%A7%88%E5%99%A8/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.png"><meta itemprop="name" content="圈圈的圈"><meta itemprop="description" content="技术学习, 读书笔记, 生活感悟 ~"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="圈圈的笔记"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> 垃圾回收机制</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2021-12-13 20:49:12" itemprop="dateCreated datePublished" datetime="2021-12-13T20:49:12+08:00">2021-12-13</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i></span> <span class="post-meta-item-text">更新于</span> <time title="修改时间：2024-06-27 23:04:43" itemprop="dateModified" datetime="2024-06-27T23:04:43+08:00">2024-06-27</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">面试</span></a></span> ， <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E9%9D%A2%E8%AF%95/%E6%B5%8F%E8%A7%88%E5%99%A8/" itemprop="url" rel="index"><span itemprop="name">浏览器</span></a></span></span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i></span> <span class="post-meta-item-text">阅读次数：</span><span id="busuanzi_value_page_pv"></span></span></div></header><div class="post-body" itemprop="articleBody"><p>所谓垃圾回收机制, 就是浏览器回收内存的方案. 在浏览器发展历程中充当了主流 GC 的方案主要有: 引用计数法和标记清除法</p><h2 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h2><p>比较初级的垃圾回收方案, 目前几乎已经被完全淘汰. 在引用计数法的机制下, 内存中每个值都会对应一个引用计数. 当垃圾回收器感受到某个值的引用计数已经为 0 时, 就判定为该变量已经是无用的变量了. 对应的内存就会被释放掉.</p><span id="more"></span><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个对象 &quot;罗小螺&quot;, 并且赋值给 man 变量, 此时对象的引用次数为 1</span></span><br><span class="line"><span class="keyword">let</span> man = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;罗小螺&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加一个 bakUp 也指向了 &quot;罗小螺&quot; 对象, 此时对象的引用次数为 2</span></span><br><span class="line"><span class="keyword">let</span> bakUp = man</span><br><span class="line"></span><br><span class="line"><span class="comment">// 断开 man 对 &quot;罗小螺&quot; 的引用, 此时对象的引用次数为 1</span></span><br><span class="line">man = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 断开 bakUp 对 &quot;罗小螺&quot; 的引用, 此时对象的引用次数为 0, 被 GC 认为</span></span><br><span class="line"><span class="comment">// 是无用对象, 垃圾收集释放内存</span></span><br><span class="line">bakUp = <span class="literal">null</span></span><br></pre></td></tr></table></figure><p>如上代码, 我们创建一个对象, 并且赋值给 man 时, 它有一个引用, 所以不会被删除, 再指定了 backUp 也指向它的时候. 引用变成两个. 只有当两个指向对象的句柄全部置为 null 的时候, GC 认为该对象没有了引用, 将其删除内存释放…</p><h3 id="引用计数法的缺点"><a href="#引用计数法的缺点" class="headerlink" title="引用计数法的缺点"></a>引用计数法的缺点</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数 func 中定义了 圈圈 和 罗小螺 两个对象</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">func</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> quanquan = &#123; <span class="attr">name</span>: <span class="string">&#x27;圈圈&#x27;</span> &#125;</span><br><span class="line">  <span class="keyword">const</span> xiaoluo = &#123; <span class="attr">name</span>: <span class="string">&#x27;罗小螺&#x27;</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行完了 func 之后 圈圈 和 罗小螺 两个对象都会被回收</span></span><br><span class="line"><span class="title function_">func</span>()</span><br></pre></td></tr></table></figure><p>函数作用域会执行完成后回收变量, 所以 func 执行完成后quanquan 和 xiaoluo引用断开对象待释放. 但是如果我们稍微改动一下代码如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数 func 中定义了 圈圈 和 罗小螺 两个对象</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">func</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> quanquan = &#123; <span class="attr">name</span>: <span class="string">&#x27;圈圈&#x27;</span> &#125;</span><br><span class="line">  <span class="keyword">const</span> xiaoluo = &#123; <span class="attr">name</span>: <span class="string">&#x27;罗小螺&#x27;</span> &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 通过循环引用, 圈圈 和 罗小螺 互相引用彼此. 引用计数法统计对象</span></span><br><span class="line">  <span class="comment">// 始终保持着一个引用便无法实现回收</span></span><br><span class="line">  xiaoluo.<span class="property">friend</span> = quanquan</span><br><span class="line">  quanquan.<span class="property">friend</span> = xiaoluo</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按理说这里执行完了 func 之后 圈圈 和 罗小螺 两个对象都会被回收</span></span><br><span class="line"><span class="title function_">func</span>()</span><br></pre></td></tr></table></figure><p>在函数体中创建的两个对象分别添加了对彼此的引用(也就是人们常说的循环引用). 当函数执行完毕后, 原本 quanquan 和 xiaoluo 变量被回收了, 但是两个对象互相引用了彼此, 所以始终存在引用, 无法实现垃圾回收和内存释放他就泄露了…</p><h2 id="标记清除法"><a href="#标记清除法" class="headerlink" title="标记清除法"></a>标记清除法</h2><p>由于引用计数法, 存在上述问题, 浏览器都开始转为使用标记清除法来实现垃圾回收. 在标记清除法中一个变量是否还有用的判断标准就是它是否可以被触达. 该算法有两个阶段:</p><ul><li>标记阶段: 垃圾回收器会先找到根对象, 从根对象出发, 扫描所有可以通过根对象触及的变量, 并将这些变量标记为可抵达</li><li>清除阶段, 经过标记阶段没有被标记为可抵达的对象, 都被认为是不需要的, 统一清除并释放内存.</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数 func 中定义了 圈圈 和 罗小螺 两个对象</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">func</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> quanquan = &#123; <span class="attr">name</span>: <span class="string">&#x27;圈圈&#x27;</span> &#125;</span><br><span class="line">  <span class="keyword">const</span> xiaoluo = &#123; <span class="attr">name</span>: <span class="string">&#x27;罗小螺&#x27;</span> &#125;</span><br><span class="line"></span><br><span class="line">  xiaoluo.<span class="property">friend</span> = quanquan</span><br><span class="line">  quanquan.<span class="property">friend</span> = xiaoluo</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 还是这张图, 函数执行完毕后从 window 算起, 无法</span></span><br><span class="line"><span class="comment">// 找到 圈圈 和 罗小螺 两个对象, 所以认为是无用的对象</span></span><br><span class="line"><span class="comment">// 将其回收</span></span><br><span class="line"><span class="title function_">func</span>()</span><br></pre></td></tr></table></figure><h2 id="常见的内存泄露原因"><a href="#常见的内存泄露原因" class="headerlink" title="常见的内存泄露原因"></a>常见的内存泄露原因</h2><ol><li>函数作用域内定义变量未使用声明符, 导致生成了全局变量</li><li>忘记清除的 setInterval 和 setTimeout</li><li>移除 Dom 未删除其引用<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个变量, 并引用 DOM 元素</span></span><br><span class="line"><span class="keyword">const</span> dom = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;dom&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除 dom 元素, 但是没有删除变量的引用</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">removeChild</span>(dom)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 小老弟, 我还在</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dom)</span><br></pre></td></tr></table></figure></li></ol><p>PS: 对于很流行的 theThing 问题, 我本地测试了一下. 现在的浏览器好像已经做过优化了. 火焰图中内存并没有阶梯递增. 而是波形的. 应该是做了优化. 所以千万不要盲目背题. 关于 theThing 问题可以看看<a target="_blank" rel="noopener" href="https://blog.meteor.com/an-interesting-kind-of-javascript-memory-leak-8b47d2e7f156">这篇文章</a>.</p></div><footer class="post-footer"><div class="post-tags"> <a href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag"># 面试</a></div><div class="post-nav"><div class="post-nav-item"><a href="/%E9%9D%A2%E8%AF%95/JavaScript/%E9%9D%A2%E8%AF%95/JavaScript/%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9%E9%97%AD%E5%8C%85%E7%9A%84%E7%90%86%E8%A7%A3/" rel="prev" title="谈谈你对闭包的理解"><i class="fa fa-chevron-left"></i> 谈谈你对闭包的理解</a></div><div class="post-nav-item"> <a href="/%E9%9D%A2%E8%AF%95/Vue/%E9%9D%A2%E8%AF%95/Vue/Vue%20%E4%B8%AD%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E5%92%8C%20method%20%E7%9A%84%E5%8C%BA%E5%88%AB/" rel="next" title="Vue 中计算属性和 method 的区别">Vue 中计算属性和 method 的区别<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div></div><script>
  window.addEventListener('tabs:register', function() {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc"> 文章目录</li><li class="sidebar-nav-overview"> 站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E6%B3%95"><span class="nav-text">引用计数法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E6%B3%95%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="nav-text">引用计数法的缺点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%E6%B3%95"><span class="nav-text">标记清除法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E5%8E%9F%E5%9B%A0"><span class="nav-text">常见的内存泄露原因</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" alt="圈圈的圈" src="/images/avatar.png"><p class="site-author-name" itemprop="name">圈圈的圈</p><div class="site-description" itemprop="description">技术学习, 读书笔记, 生活感悟 ~</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"> <a href="/archives/"><span class="site-state-item-count">142</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"> <a href="/categories/"><span class="site-state-item-count">35</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"> <a href="/tags/"><span class="site-state-item-count">8</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://juejin.im/user/5837c2bd61ff4b006ca8d1b2" title="掘金 → https:&#x2F;&#x2F;juejin.im&#x2F;user&#x2F;5837c2bd61ff4b006ca8d1b2" rel="noopener" target="_blank"><i class="fa fa-fw fa-stack-overflow"></i> 掘金</a></span><span class="links-of-author-item"><a href="https://github.com/luoquanquan" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;luoquanquan" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i> GitHub</a></span><span class="links-of-author-item"><a href="mailto:luo_quanquan@163.com" title="E-Mail → mailto:luo_quanquan@163.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i> E-Mail</a></span></div></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="beian"><a href="http://www.beian.miit.gov.cn/" rel="noopener" target="_blank">京ICP备17034706号-1</a></div><div class="copyright"> &copy; <span itemprop="copyrightYear">2024</span><span class="with-love"><i class="fa fa-user"></i></span> <span class="author" itemprop="copyrightHolder">圈圈的圈</span></div><div class="busuanzi-count"><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="post-meta-item" id="busuanzi_container_site_uv"><span class="post-meta-item-icon"><i class="fa fa-user"></i></span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span></span></span> <span class="post-meta-divider">|</span><span class="post-meta-item" id="busuanzi_container_site_pv"><span class="post-meta-item-icon"><i class="fa fa-eye"></i></span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div></div></footer></div><script color="0,0,255" opacity="0.5" zindex="-1" count="99" src="/js/theme-next-canvas-nest/canvas-nest.min.js"></script><script src="/lib/anime.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script><script src="/js/local-search.js"></script></body></html>